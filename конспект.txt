ТИПЫ ДАННЫХ

Типы данных делятся на две группы: простые (они неизменяемы) типы и объекты (изменяеые). Для простых типов есть обертки, которые могут неявно вызываться для переменных и литералов
Простые:
 - number
 - string
 - boolean
 - null
 - undefined
Однако typeof для null выведет object. Undefined, а также Infinity и NaN, являются идентификаторами (синглтонами?)

 Объектные типы:
 - объекты {name: ivan}
 - массивы [1, 2, 3]
 - регулярки /w+/g
 - функции function(){}

 Однако typeof для function выведет function

 JS имеет динамическую типизацию, то есть объявив и инициалзировав переменную можно потом поменять тип ее значений, например, с number на string. В JS есть автоматическая конвертация типа, если парсер ожидает увидеть, например, boolean, то он будет приводить переменную к этому типу, независимо, от того что там сейчас есть.

 Тип number используется как для целых, так и для вещественных значений. Целые чилса можно записывать в 16-ричный системе, для этого необходимо в начале написать 0x, например, 0xf. Для записи вещественных используется . или его экспоненциальная запись. Например, .89 <=> 0.89 <=> 8.9e-1. 
 Полезные методы обертки Number:
 - toFixed(n) - n-количество значков после запятой. 
 - toExponential(n) - n- степень
 - toPecision(n) - n - количество значащих цифр
 Методы для литералов вызываются после пробела. Например, 2 .toFixed(2). Есть значения Infinity и NaN.

Строковый литерал записывается с помощью "" или ''. Это можно использвать для вывода кавычек, однако проще использовать экранирование с помощью \. В JS нет типа char, поэтому используется строка единичной длины. 
Полезные методы, свойства и последовательности:
- length 
- \n \t - переход на новую строку и табуляция
- charAt(x) <=>  string[x]
- substring(x) - подстрока с индекса x и до конца 
- substring(x1, x2) - подстрока с индекса x1 и до x2, не включая
- sclice(x) - аналогичен substring, но может принимать отрицательные значения, что означает идти с конца
- substr(x, n) - подстрока с индекса x из n символов
- indexOf(substr) - возвращает индекс первого вхождения в строку
- lastIndexOf(substr) - возвращает индекс последнего вхождения в строку
- replace(substr1, substr2) - заменить посдстроку substr1 подстрокой substr2
- split(delimiter) - разбиение строки на масив строк
- toUpperCase() и  toLowerCase()

К логическому значению может быть приведено любое значение. Есть список значений кроме литерала false, которые также приводятся к значению false. Это: undefined, null, 0, "", NaN

Значение undefined имеют:
- неинициализированные переменные
- обращение к несуществующему свойству объекта
- обращение к несущетсвующему элементу массива
- обращение к параметру функции, которому не было ничего передано. Например, sqrt(), так как не было передан параметр.
- если функция ничего не возвращает, то это значание будет undefined

_________________________________________________________________________________________________________________

ОБЪЯВЛЕНИЕ И РАБОТА С ПЕРЕМЕННЫМИ

var a = 5;
var b = c = "string";
var _d = 4, $f = "";

var obj = {name: "ivan"}
obj.name = "vasya"

var ar = [1, 2, 3]
ar[1] = 10
var _a 
isTrue && _a = 5 - присвоит значение переменной -а только, если isTrue = true
var _b = b || "Default string" - инициализирует переменную значением из b, если оно есть, или "Default string"

___________________________________________________________________________________________________________

ОПРЕАТОРЫ
- унарные (+, -, typeof, ++, --, !, delete)
- бинарные (+, -, /, *, %, <, >, <=, >=, ===, !==, &&, ||, instanceof) / - нецелочисленное
- тернарный ( ? :)

Есть бинарный оператор запятая (выражение1, выражение2). Вычисляется выражение1, потом выражение2, которое и возврщается
var a = (1, 2) <=> a = 2
_________________________________________________________________________________________________________________

ПРЕОБРАЗОВАНИЕ ТИПОВ

5 + "" => string
5 * "4" => number
!!4 => boolean
+"5" => number  +"" = 0  +"45 px" = NaN

2.toString(radix)
parseInt("45 px") parseInt("45 px", 10) => 45
parseFloat()
___________________________________________________________________________________________________________________

ЦИКЛЫ

var i;
for (i=10;i--;) {}

for (property in person) {
	
}
______________________________________________________________________________________________________________________

ФУНКЦИИ

functions name(argsList) { ... return ...}
var f = function(args) {}; - объявление с инициализацией переменной с помощью анонимной функции

Для получения значений всех аргументов, переданных функции есть массив arguments.
В JS функции являются объектами, поэтому их можно передавать в качестве аргументов, а также возвращать из других функций

var func = function(callback){
	var name = ivan
	return callback(name)
};

func(function(name){
	console.log("Hello "+ name)
})

Существует три метода для указания функции, свойство какого объекта свледует использовать. Это call, apply и bind

var greet = function(){
	return "My name is "+ this.name;
};
var person = {					var anotherPerson = {
	name: "Ivan",					name: "Bob",
	g: greet						g: greet
};								}
console.log(person.g())
console.log(person.g.call(anotherPerson))   <=> console.log(person.g.apply(anotherPerson))
var bound = greet.bind(person)
_______________________________________________________________________________________________________________________

ОБЪЕКТЫ
Объект - набор свойств, который представляет из себя пары имя-значение. Свойство можно добавлять "на лету". Если свойство определяется функцией, то он называется методом.
Для создания объектов можноиспользовать литерал (см. ниже), создать объект типа Object и "навесить" ему свойств, использовать статический метод Object.create(прототип_объекта)
Для удаления свойств объектов используется опереатор delete. Для проверки наличия свойства в объекте есть оператор in

var person = {
				name: "ivan",
				age: 33
			 }
person.name  или person["name"]
person.id = 156
delete person.id
"id" in person

Для обращение к внутренним свойствам объекта используется this.свойство.
Любое свойство объекта имеет 4 атрибута:
- value
- writable
- enumerable
- configurable
Их значения можно получить с помощью Object.getOwnPropertyDescriptor(person, "name")
Object.defineProperty(person, "gender", {
	value: "male",
	writable: false,
	enumerable: false,		влияет на цикл for in
	configurable: false		можно ли менять в дальнейшем атрибуты или удалять
})

Для предотвращения добавления новых свойств к объекту можно использовать Object.preventEctensions(person)
Object.seal(person) = Object.preventEctensions(person) + configurable:false
Object.freeze(person) = Object.sealed(person) + нельзя изменять свойства объекта

______________________________________________________________________________________________________________

НАСЛЕДОВАНИЕ И ПРОТОТИПЫ

В JS есть только наследование прототипов с помощью статического метода Object.create(прототип_объекта)
Под классом в JS подразумевают множество всех объектов, которые наследуют все свойства от одного прототипа.
var Person = {
	constructor: function(name, age, gender) {
		this.name = name
		this.age = age
		this.gender = gender
		return = this
	}
}
var Dev = Object.create(Person)
dev.constructor = function(name, age, gender, skills) {
	Person.constructor.apply(this, arguments)
	this.skills = skills || []
	return this
}

var p1 = new Person("Ivan", 33, "male")
var d1 = new Dev("Ivan", 33, "male", ["Java", "Scala"])

Поля и функции в главном класск можно не определять напрямую в конструктуре и прописывая явно, а "навешивать" на поле prototype.
Person.prototype.greet(name) = function () {
	console.log("Hello, my name is " + this.name)
}

Для получения прототипа объекта есть метод __proto__
Для переопределения метода надо написать

Person.prototype.toString = function() {
	return this.name
}
________________________________________________________________________________________________________________

МАССИВЫ
var array = [1, 2, 3, 4]
var array[array.length] = 5 - добавить еще 1 элемент в конец
array[20] = 20 -  добавит элемент. При этом длина массива считается, как индекс поледнего элемента +1, то есть станет 21!
У массивов есть конструктор
var arr = new Array(1 ,2, 3) - если передать один аргумент, то создастся массив с указанным числом элементов. Однако смысла нет, так  как все массивы динамические
var a = [,,,1] - пропускает первые 3 элемента и инициализирует только 4 элемент
В массивах индексы хранятся в виде строк, то есть массив в действительности это Map[String, Object]. Однако индексы это неотрицательные целые числа
array["hello"] = 5 - добавит свойство масиву
array.length = 3 - удалит все элементы с индексом больше 2
delete array[0] - удаляет значение под индексом 0, но элемент не удаляется и длина не изменяется

Методы
Array.isArray(array) - проверит, является array массивом
array.join() или array.join("...") - для объединения в строку всх элементов массива
array.indexOf(x) и array.lastIndexOf(x) - вернут индекс элемента
array.reverse() - обратный массив, изменяет исходный
array.sort() или array.sort(fuction(a,b){}) - для сортировки массива
array.slice(x) - аналогичен методу для строк. Не изменяет исходный массив
array.splice(x, y, a0, a1, a3) - удалит y элемент, начиная с x, а потом вставит туда a0, a1, a2
array.push(x) - добавит элемент в конец 
array.unshift(x) - добавит элемент в начало массива
array.pop() - удаляет последний элемент и его возвращает
array.shift() - удаляет первый элемент и его возвращает

var arr = ["String1", "String2", "String3", "Hello"]
arr.forEach(function(el, ind, arr){
	arr[ind] = el.toUpperCase();
});
arr.map(function(e){return e.toUpperCase()});
arr.filter(function(e){return e.indexOf('o')===-1})
arr.every(function(e){return e.length>4}) - все ли элементы удовлетворяют данному условию
arr.some(function(e){}) - есть ли хоть один элемент, для которого ...

var numbers = [1, 2, 3, 4]
numbers.reduce(function(a, b, index, array){}) - необязательно писать все аргументы. a - промежуточное значение, b - текущий элемент
numbers.reduce(function(a, b){return a + b})
numbers.reduceRight(...) - проходит справа налево массив
________________________________________________________________________________________________________________

СЕРИАЛИЗАЦИЯ И JSON

Сериализация - преобразование объектов в строки
var user = {id: 2312, age:23}
jsonUser = Json.stringify(user) - перевод в строку
initial = Json.parse(jsonUser) - перевод в объект
Метод stringify() ищет у объекта метод toJSON, который и используется.
_________________________________________________________________________

КЛАСС Date
var date = new Date() - текущая дата
date = new Date(2019,0,1,0,0,0) // (Y, M, D, H, M, S, MS) полночь 1ого Января
date.getHours(), date.getSeconds(), getYear() и  getFullYear()
date.setHours(), date.setSeconds(), setYear() и  setFullYear()

date.getTime() - вернет мс с 01,01,1970

date.getUTCHours() - вернет локальное время

date.toTimeString() - вывод только времени
date.toDateString() - вывод только даты
Date.now() - вернет текущее время в мс

______________________________________________________________________________________________________________________________

РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
https://www.youtube.com/watch?v=9hLkbhRs7jM&t=545s
\d - все цифры      \D - все кроме цифр     \w - цифры+буквы        \W - не цифры и не буквы        \s - пустые символы(пробелы, табы, перееносы строк)     
\b - граница слова, например, \ban\b - найдет все артикли a
| - логическое или \bme\b|\band|b  - найти слова me или and, gr(a|e)y - найти слова gray и grey, cent(er|re) - center/centre
colou?r - color/colour
\. - найти точку, а просто . найдет все символы, кроме переноса строк
a...y <=> a.{3}y - найдет сочетание из 5 символов, начинающихся на a и заканчивающихся на e
a.{2,6}y - длина предыдущего сочетания от 4 до 8

var pattern = new RegEx("\w+", "gim"); - первый аргумент регулярка, второй флаги: g - global(все вхождения, иначе первое), i - ignore case, m - multiline
var samePattern = /\w+/gim;
var string = "Something to practice"
string.match(pattern) => [Something,to,practice]
string.search(pattern) => 0
__________________________________________________________________________

БРАУЗЕР
alert("") // confirm("") // promt("")
document.write("") - вывод текста на станицу